"""Stripe Connect service for payment processing.

Integrates with Stripe Connect for:
- OAuth-based account connection
- Creating checkout sessions for one-time payments
- Creating subscriptions for recurring billing
- Handling webhook events
- Platform fee collection via application_fee_percent
"""

import base64
import hashlib
import hmac
import json
import os
import time
from datetime import datetime, timezone
from enum import Enum
from typing import Any
from urllib.parse import quote, unquote

import boto3
import structlog

logger = structlog.get_logger()

# Stripe API key - stored in environment/Parameter Store
STRIPE_SECRET_KEY = os.environ.get("STRIPE_SECRET_KEY", "")
STRIPE_PUBLISHABLE_KEY = os.environ.get("STRIPE_PUBLISHABLE_KEY", "")
STRIPE_WEBHOOK_SECRET = os.environ.get("STRIPE_WEBHOOK_SECRET", "")
STRIPE_CONNECT_CLIENT_ID = os.environ.get("STRIPE_CONNECT_CLIENT_ID", "")

# Platform fee percentage (2% = 0.02)
PLATFORM_FEE_PERCENT = float(os.environ.get("STRIPE_PLATFORM_FEE_PERCENT", "0.02"))

# State token validity period (5 minutes)
# Note: OAUTH_STATE_SECRET is read at call time via _get_state_encryption_key()
# Use: openssl rand -hex 32 to generate the secret
STATE_TOKEN_TTL_SECONDS = 300


def _get_state_encryption_key() -> str:
    """Get OAuth state encryption key from environment.

    This reads the env var at call time to support testing and env changes.
    """
    return os.environ.get("OAUTH_STATE_SECRET", "")


class StripeError(Exception):
    """Stripe operation error."""

    def __init__(self, message: str, code: str = "stripe_error"):
        self.message = message
        self.code = code
        super().__init__(message)


class PaymentStatus(str, Enum):
    """Payment status enum."""

    PENDING = "pending"
    SUCCEEDED = "succeeded"
    FAILED = "failed"
    REFUNDED = "refunded"
    CANCELLED = "cancelled"


def encrypt_oauth_state(data: dict) -> str:
    """Encrypt OAuth state parameter with HMAC signature.

    SECURITY: This prevents attackers from forging state parameters to
    associate OAuth responses with arbitrary workspaces.

    Args:
        data: State data including workspace_id.

    Returns:
        Base64-encoded encrypted state with signature.

    Raises:
        StripeError: If encryption key is not configured.
    """
    encryption_key = _get_state_encryption_key()
    if not encryption_key:
        logger.error("CONFIGURATION ERROR: OAUTH_STATE_SECRET not configured")
        raise StripeError(
            "OAuth state encryption not configured", "config_error"
        )

    # Add timestamp for expiry validation
    data["_ts"] = int(time.time())

    # Serialize the data
    payload = json.dumps(data, separators=(",", ":"))

    # Create HMAC signature
    signature = hmac.new(
        encryption_key.encode("utf-8"),
        payload.encode("utf-8"),
        hashlib.sha256,
    ).hexdigest()

    # Combine payload and signature
    combined = f"{payload}:{signature}"

    # Base64 encode for URL safety
    encoded = base64.urlsafe_b64encode(combined.encode("utf-8")).decode("utf-8")

    return encoded


def decrypt_oauth_state(encrypted_state: str) -> dict:
    """Decrypt and verify OAuth state parameter.

    SECURITY: This verifies the state was generated by our server and
    has not been tampered with. Also checks for expiry to prevent replay attacks.

    Args:
        encrypted_state: The encrypted state from OAuth callback.

    Returns:
        Decrypted state data.

    Raises:
        StripeError: If state is invalid, tampered, or expired.
    """
    encryption_key = _get_state_encryption_key()
    if not encryption_key:
        logger.error("CONFIGURATION ERROR: OAUTH_STATE_SECRET not configured")
        raise StripeError(
            "OAuth state encryption not configured", "config_error"
        )

    try:
        # Decode base64
        decoded = base64.urlsafe_b64decode(encrypted_state.encode("utf-8")).decode("utf-8")

        # Split payload and signature
        if ":" not in decoded:
            raise ValueError("Invalid state format")

        payload, provided_signature = decoded.rsplit(":", 1)

        # Verify signature
        expected_signature = hmac.new(
            encryption_key.encode("utf-8"),
            payload.encode("utf-8"),
            hashlib.sha256,
        ).hexdigest()

        if not hmac.compare_digest(provided_signature, expected_signature):
            logger.warning(
                "SECURITY: OAuth state signature mismatch - possible tampering",
                provided_sig_prefix=provided_signature[:10] + "...",
            )
            raise StripeError("Invalid state signature", "invalid_state")

        # Parse payload
        data = json.loads(payload)

        # Check expiry
        timestamp = data.get("_ts", 0)
        if time.time() - timestamp > STATE_TOKEN_TTL_SECONDS:
            logger.warning(
                "SECURITY: OAuth state expired",
                age_seconds=int(time.time() - timestamp),
            )
            raise StripeError("State token expired", "state_expired")

        # Remove internal fields before returning
        data.pop("_ts", None)

        return data

    except (ValueError, json.JSONDecodeError) as e:
        logger.warning("SECURITY: OAuth state decode failed", error=str(e))
        raise StripeError("Invalid state parameter", "invalid_state")


def get_stripe_client():
    """Get configured Stripe client.

    Returns:
        Stripe module with API key set.

    Raises:
        StripeError: If Stripe is not configured.
    """
    if not STRIPE_SECRET_KEY:
        raise StripeError("Stripe is not configured", "not_configured")

    try:
        import stripe

        stripe.api_key = STRIPE_SECRET_KEY
        return stripe
    except ImportError:
        raise StripeError("Stripe library not installed", "missing_dependency")


def generate_connect_oauth_url(
    workspace_id: str,
    redirect_uri: str,
    state: str | None = None,
) -> str:
    """Generate OAuth URL for Stripe Connect onboarding.

    SECURITY: The state parameter is encrypted and signed to prevent:
    - Tampering (attacker changing workspace_id to hijack connection)
    - Replay attacks (state expires after 5 minutes)
    - CSRF attacks (state ties the OAuth flow to the original request)

    Args:
        workspace_id: Workspace ID for state tracking.
        redirect_uri: URL to redirect after OAuth.
        state: Optional custom state data.

    Returns:
        OAuth authorization URL.
    """
    if not STRIPE_CONNECT_CLIENT_ID:
        raise StripeError("Stripe Connect not configured", "not_configured")

    # SECURITY: Encrypt state to prevent tampering with workspace_id
    state_data = {"workspace_id": workspace_id}
    if state:
        state_data["custom"] = state

    encrypted_state = encrypt_oauth_state(state_data)

    params = {
        "response_type": "code",
        "client_id": STRIPE_CONNECT_CLIENT_ID,
        "scope": "read_write",
        "redirect_uri": redirect_uri,
        "state": quote(encrypted_state, safe=""),  # URL-encode the state
    }

    query_string = "&".join(f"{k}={v}" for k, v in params.items())
    return f"https://connect.stripe.com/oauth/authorize?{query_string}"


def complete_connect_oauth(
    authorization_code: str,
) -> dict:
    """Complete Stripe Connect OAuth flow.

    Args:
        authorization_code: Code from OAuth redirect.

    Returns:
        Dict with stripe_user_id, access_token, etc.
    """
    stripe = get_stripe_client()

    try:
        response = stripe.OAuth.token(
            grant_type="authorization_code",
            code=authorization_code,
        )

        return {
            "stripe_user_id": response.stripe_user_id,
            "access_token": response.access_token,
            "refresh_token": response.get("refresh_token"),
            "livemode": response.livemode,
            "scope": response.scope,
        }
    except stripe.error.OAuthError as e:
        raise StripeError(f"OAuth failed: {e.user_message}", "oauth_error")
    except stripe.error.StripeError as e:
        raise StripeError(f"Stripe error: {str(e)}", "stripe_error")


def create_checkout_session(
    connected_account_id: str,
    workspace_id: str,
    price_data: dict,
    success_url: str,
    cancel_url: str,
    customer_email: str | None = None,
    metadata: dict | None = None,
    mode: str = "payment",
) -> dict:
    """Create a Stripe Checkout session for a connected account.

    Args:
        connected_account_id: Stripe connected account ID.
        workspace_id: Workspace ID.
        price_data: Price configuration (amount, currency, product_name).
        success_url: URL for successful payment redirect.
        cancel_url: URL for cancelled payment redirect.
        customer_email: Optional customer email.
        metadata: Optional metadata to attach.
        mode: "payment" for one-time, "subscription" for recurring.

    Returns:
        Dict with session_id, url, etc.
    """
    stripe = get_stripe_client()

    line_items = []

    if mode == "payment":
        # One-time payment
        line_items.append({
            "price_data": {
                "currency": price_data.get("currency", "usd"),
                "product_data": {
                    "name": price_data.get("product_name", "Payment"),
                    "description": price_data.get("description"),
                },
                "unit_amount": int(price_data.get("amount", 0) * 100),  # Convert to cents
            },
            "quantity": price_data.get("quantity", 1),
        })
    else:
        # Subscription - requires a price ID
        if "price_id" in price_data:
            line_items.append({
                "price": price_data["price_id"],
                "quantity": price_data.get("quantity", 1),
            })
        else:
            # Create inline price for subscription
            line_items.append({
                "price_data": {
                    "currency": price_data.get("currency", "usd"),
                    "product_data": {
                        "name": price_data.get("product_name", "Subscription"),
                    },
                    "unit_amount": int(price_data.get("amount", 0) * 100),
                    "recurring": {
                        "interval": price_data.get("interval", "month"),
                    },
                },
                "quantity": price_data.get("quantity", 1),
            })

    session_params = {
        "mode": mode,
        "line_items": line_items,
        "success_url": success_url,
        "cancel_url": cancel_url,
        "metadata": {
            "workspace_id": workspace_id,
            **(metadata or {}),
        },
    }

    # Platform fee via application_fee_percent
    if PLATFORM_FEE_PERCENT > 0:
        if mode == "payment":
            session_params["payment_intent_data"] = {
                "application_fee_amount": int(
                    price_data.get("amount", 0) * 100 * PLATFORM_FEE_PERCENT
                ),
            }
        else:
            session_params["subscription_data"] = {
                "application_fee_percent": PLATFORM_FEE_PERCENT * 100,
            }

    if customer_email:
        session_params["customer_email"] = customer_email

    try:
        session = stripe.checkout.Session.create(
            **session_params,
            stripe_account=connected_account_id,
        )

        return {
            "session_id": session.id,
            "url": session.url,
            "status": session.status,
            "payment_status": session.payment_status,
        }
    except stripe.error.StripeError as e:
        logger.error("Checkout session creation failed", error=str(e))
        raise StripeError(f"Failed to create checkout: {str(e)}", "checkout_error")


def create_payment_link(
    connected_account_id: str,
    workspace_id: str,
    price_data: dict,
    metadata: dict | None = None,
) -> dict:
    """Create a reusable payment link.

    Args:
        connected_account_id: Stripe connected account ID.
        workspace_id: Workspace ID.
        price_data: Price configuration.
        metadata: Optional metadata.

    Returns:
        Dict with payment link details.
    """
    stripe = get_stripe_client()

    try:
        # First create a product and price
        product = stripe.Product.create(
            name=price_data.get("product_name", "Payment"),
            description=price_data.get("description"),
            stripe_account=connected_account_id,
        )

        price = stripe.Price.create(
            product=product.id,
            currency=price_data.get("currency", "usd"),
            unit_amount=int(price_data.get("amount", 0) * 100),
            stripe_account=connected_account_id,
        )

        # Create payment link
        link_params = {
            "line_items": [{"price": price.id, "quantity": 1}],
            "metadata": {
                "workspace_id": workspace_id,
                **(metadata or {}),
            },
        }

        if PLATFORM_FEE_PERCENT > 0:
            link_params["application_fee_percent"] = PLATFORM_FEE_PERCENT * 100

        link = stripe.PaymentLink.create(
            **link_params,
            stripe_account=connected_account_id,
        )

        return {
            "link_id": link.id,
            "url": link.url,
            "active": link.active,
            "product_id": product.id,
            "price_id": price.id,
        }
    except stripe.error.StripeError as e:
        logger.error("Payment link creation failed", error=str(e))
        raise StripeError(f"Failed to create payment link: {str(e)}", "link_error")


def verify_webhook_signature(
    payload: bytes | str,
    signature: str,
    secret: str | None = None,
) -> dict:
    """Verify and parse Stripe webhook payload.

    Args:
        payload: Raw request body.
        signature: Stripe-Signature header value.
        secret: Webhook secret (uses env var if not provided).

    Returns:
        Parsed webhook event.

    Raises:
        StripeError: If signature is invalid.
    """
    stripe = get_stripe_client()
    webhook_secret = secret or STRIPE_WEBHOOK_SECRET

    if not webhook_secret:
        raise StripeError("Webhook secret not configured", "not_configured")

    try:
        event = stripe.Webhook.construct_event(
            payload,
            signature,
            webhook_secret,
        )
        return event
    except stripe.error.SignatureVerificationError:
        raise StripeError("Invalid webhook signature", "invalid_signature")
    except Exception as e:
        raise StripeError(f"Webhook verification failed: {str(e)}", "webhook_error")


def get_account_status(connected_account_id: str) -> dict:
    """Get status of a connected Stripe account.

    Args:
        connected_account_id: Stripe account ID.

    Returns:
        Account status details.
    """
    stripe = get_stripe_client()

    try:
        account = stripe.Account.retrieve(connected_account_id)

        return {
            "id": account.id,
            "business_type": account.business_type,
            "charges_enabled": account.charges_enabled,
            "payouts_enabled": account.payouts_enabled,
            "details_submitted": account.details_submitted,
            "email": account.email,
            "country": account.country,
            "default_currency": account.default_currency,
        }
    except stripe.error.StripeError as e:
        logger.error("Failed to get account status", error=str(e))
        raise StripeError(f"Failed to get account: {str(e)}", "account_error")


def refund_payment(
    connected_account_id: str,
    payment_intent_id: str,
    amount: float | None = None,
    reason: str | None = None,
) -> dict:
    """Refund a payment.

    Args:
        connected_account_id: Stripe connected account ID.
        payment_intent_id: Payment intent to refund.
        amount: Amount to refund (full refund if not specified).
        reason: Refund reason.

    Returns:
        Refund details.
    """
    stripe = get_stripe_client()

    refund_params = {
        "payment_intent": payment_intent_id,
    }

    if amount is not None:
        refund_params["amount"] = int(amount * 100)

    if reason:
        refund_params["reason"] = reason

    try:
        refund = stripe.Refund.create(
            **refund_params,
            stripe_account=connected_account_id,
        )

        return {
            "id": refund.id,
            "amount": refund.amount / 100,
            "currency": refund.currency,
            "status": refund.status,
            "reason": refund.reason,
        }
    except stripe.error.StripeError as e:
        logger.error("Refund failed", error=str(e))
        raise StripeError(f"Refund failed: {str(e)}", "refund_error")


def cancel_subscription(
    connected_account_id: str,
    subscription_id: str,
    immediately: bool = False,
) -> dict:
    """Cancel a subscription.

    Args:
        connected_account_id: Stripe connected account ID.
        subscription_id: Subscription to cancel.
        immediately: If True, cancel immediately; otherwise at period end.

    Returns:
        Cancelled subscription details.
    """
    stripe = get_stripe_client()

    try:
        if immediately:
            subscription = stripe.Subscription.delete(
                subscription_id,
                stripe_account=connected_account_id,
            )
        else:
            subscription = stripe.Subscription.modify(
                subscription_id,
                cancel_at_period_end=True,
                stripe_account=connected_account_id,
            )

        return {
            "id": subscription.id,
            "status": subscription.status,
            "cancel_at_period_end": subscription.cancel_at_period_end,
            "current_period_end": subscription.current_period_end,
        }
    except stripe.error.StripeError as e:
        logger.error("Subscription cancellation failed", error=str(e))
        raise StripeError(f"Cancellation failed: {str(e)}", "cancel_error")


# Helper function to convert Stripe event to workflow trigger data
def event_to_trigger_data(event: dict) -> dict:
    """Convert Stripe webhook event to workflow trigger data.

    Args:
        event: Stripe webhook event.

    Returns:
        Trigger data for workflow.
    """
    event_type = event.get("type", "")
    data = event.get("data", {}).get("object", {})

    trigger_data = {
        "event_type": event_type,
        "event_id": event.get("id"),
        "created": event.get("created"),
    }

    # Extract common fields
    if "customer_email" in data:
        trigger_data["customer_email"] = data["customer_email"]
    if "customer" in data:
        trigger_data["customer_id"] = data["customer"]
    if "amount" in data:
        trigger_data["amount"] = data["amount"] / 100
    if "currency" in data:
        trigger_data["currency"] = data["currency"]
    if "metadata" in data:
        trigger_data["metadata"] = data["metadata"]

    # Event-specific fields
    if event_type == "checkout.session.completed":
        trigger_data["session_id"] = data.get("id")
        trigger_data["mode"] = data.get("mode")
        trigger_data["payment_status"] = data.get("payment_status")

    elif event_type == "payment_intent.succeeded":
        trigger_data["payment_intent_id"] = data.get("id")
        trigger_data["amount"] = data.get("amount_received", 0) / 100

    elif event_type.startswith("customer.subscription"):
        trigger_data["subscription_id"] = data.get("id")
        trigger_data["status"] = data.get("status")
        trigger_data["current_period_end"] = data.get("current_period_end")

    elif event_type == "invoice.paid":
        trigger_data["invoice_id"] = data.get("id")
        trigger_data["amount_paid"] = data.get("amount_paid", 0) / 100
        trigger_data["subscription_id"] = data.get("subscription")

    return trigger_data
