name: Deploy Complens.ai

on:
  push:
    branches:
      # - main  # DISABLED: Prevent auto-deploy to prod on merge
      - 'claude/**'  # Allow deployments from claude branches for testing
  workflow_dispatch:  # Manual triggers only for prod
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod

env:
  AWS_REGION: us-east-1
  NODE_VERSION: '20'

jobs:
  # Determine environment based on branch
  setup:
    name: Setup Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      deploy-infra: ${{ steps.changes.outputs.infrastructure }}
      deploy-backend: ${{ steps.changes.outputs.backend }}
      deploy-frontend: ${{ steps.changes.outputs.frontend }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need 2 commits to detect changes

      - name: Determine environment
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            # Main branch pushes no longer trigger automatic deployment
            # Use workflow_dispatch (manual trigger) to deploy to prod
            echo "environment=dev" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi

      - name: Detect changes
        id: changes
        run: |
          if git diff --name-only HEAD~1 HEAD | grep -q "^infrastructure/"; then
            echo "infrastructure=true" >> $GITHUB_OUTPUT
          else
            echo "infrastructure=false" >> $GITHUB_OUTPUT
          fi

          if git diff --name-only HEAD~1 HEAD | grep -q "^backend/"; then
            echo "backend=true" >> $GITHUB_OUTPUT
          else
            echo "backend=false" >> $GITHUB_OUTPUT
          fi

          if git diff --name-only HEAD~1 HEAD | grep -q "^frontend/"; then
            echo "frontend=true" >> $GITHUB_OUTPUT
          else
            echo "frontend=false" >> $GITHUB_OUTPUT
          fi

  # Deploy infrastructure with CloudFormation
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.deploy-infra == 'true' || github.event_name == 'workflow_dispatch'
    environment:
      name: ${{ needs.setup.outputs.environment }}
    outputs:
      api-url: ${{ steps.stack-outputs.outputs.api-url }}
      frontend-bucket: ${{ steps.stack-outputs.outputs.frontend-bucket }}
      lambda-bucket: ${{ steps.stack-outputs.outputs.lambda-bucket }}
      cloudfront-id: ${{ steps.stack-outputs.outputs.cloudfront-id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Validate CloudFormation template
        run: |
          cd infrastructure/cloudformation
          aws cloudformation validate-template \
            --template-body file://main.yaml \
            --region ${{ env.AWS_REGION }}

      - name: Prepare Lambda code bucket and placeholder
        run: |
          # Get AWS account ID
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ENV="${{ needs.setup.outputs.environment }}"
          BUCKET_NAME="${ACCOUNT_ID}-${ENV}-complens-lambda-code"

          echo "ðŸ”‘ AWS Account: ${ACCOUNT_ID}"
          echo "ðŸ“¦ Lambda bucket name: ${BUCKET_NAME}"

          # Check if bucket exists
          if aws s3 ls "s3://${BUCKET_NAME}" --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "âœ… Lambda code bucket already exists: ${BUCKET_NAME}"
          else
            echo "ðŸ“¦ Creating Lambda code bucket: ${BUCKET_NAME}"
            aws s3 mb "s3://${BUCKET_NAME}" --region ${{ env.AWS_REGION }}

            # Enable versioning for Lambda deployments
            aws s3api put-bucket-versioning \
              --bucket ${BUCKET_NAME} \
              --versioning-configuration Status=Enabled \
              --region ${{ env.AWS_REGION }}

            # Enable encryption
            aws s3api put-bucket-encryption \
              --bucket ${BUCKET_NAME} \
              --server-side-encryption-configuration '{
                "Rules": [{
                  "ApplyServerSideEncryptionByDefault": {
                    "SSEAlgorithm": "AES256"
                  }
                }]
              }' \
              --region ${{ env.AWS_REGION }}

            # Block public access
            aws s3api put-public-access-block \
              --bucket ${BUCKET_NAME} \
              --public-access-block-configuration \
                "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true" \
              --region ${{ env.AWS_REGION }}
          fi

          # Check if placeholder or real code exists
          if aws s3 ls "s3://${BUCKET_NAME}/api/latest.zip" --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "âœ… Lambda code already exists in bucket"
          else
            echo "ðŸ“¤ Uploading placeholder Lambda code..."
            aws s3 cp infrastructure/lambda-placeholder.zip \
              "s3://${BUCKET_NAME}/api/latest.zip" \
              --region ${{ env.AWS_REGION }}
            echo "âš ï¸  Placeholder uploaded - real code will be deployed later"
          fi

      - name: Deploy CloudFormation stack
        id: deploy-stack
        env:
          DB_PASSWORD: ${{ secrets.DB_MASTER_PASSWORD }}
          BILLING_EMAIL: ${{ secrets.BILLING_ALERT_EMAIL }}
          BEDROCK_MODEL_ID: ${{ secrets.BEDROCK_MODEL_ID }}
          BEDROCK_SECURITY_MODEL_ID: ${{ secrets.BEDROCK_SECURITY_MODEL_ID }}
        run: |
          cd infrastructure/cloudformation

          STACK_NAME="complens-${{ needs.setup.outputs.environment }}"
          ENV="${{ needs.setup.outputs.environment }}"

          # Prepare parameters with overrides from secrets
          PARAMS=$(jq \
            --arg pwd "$DB_PASSWORD" \
            --arg email "$BILLING_EMAIL" \
            --arg model "${BEDROCK_MODEL_ID:-us.amazon.nova-lite-v1:0}" \
            --arg secmodel "${BEDROCK_SECURITY_MODEL_ID:-us.anthropic.claude-3-5-sonnet-20241022-v2:0}" \
            'map(
              if .ParameterKey == "DBMasterPassword" then .ParameterValue = $pwd
              elif .ParameterKey == "BillingAlertEmail" then .ParameterValue = $email
              elif .ParameterKey == "BedrockModelId" then .ParameterValue = $model
              elif .ParameterKey == "BedrockSecurityModelId" then .ParameterValue = $secmodel
              else . end
            )' \
            parameters/${ENV}.json)

          # Check if stack exists
          if aws cloudformation describe-stacks --stack-name ${STACK_NAME} --region ${{ env.AWS_REGION }} 2>&1 | grep -q "does not exist"; then
            echo "Creating new stack..."
            aws cloudformation create-stack \
              --stack-name ${STACK_NAME} \
              --template-body file://main.yaml \
              --parameters "$PARAMS" \
              --capabilities CAPABILITY_NAMED_IAM \
              --region ${{ env.AWS_REGION }} \
              --tags \
                Key=Environment,Value=${ENV} \
                Key=Project,Value=Complens \
                Key=ManagedBy,Value=GitHubActions

            echo "Waiting for stack creation..."
            aws cloudformation wait stack-create-complete \
              --stack-name ${STACK_NAME} \
              --region ${{ env.AWS_REGION }}
          else
            echo "Updating existing stack..."
            UPDATE_OUTPUT=$(aws cloudformation update-stack \
              --stack-name ${STACK_NAME} \
              --template-body file://main.yaml \
              --parameters "$PARAMS" \
              --capabilities CAPABILITY_NAMED_IAM \
              --region ${{ env.AWS_REGION }} 2>&1 || true)

            if echo "$UPDATE_OUTPUT" | grep -q "No updates are to be performed"; then
              echo "No updates needed"
            else
              echo "Waiting for stack update..."
              aws cloudformation wait stack-update-complete \
                --stack-name ${STACK_NAME} \
                --region ${{ env.AWS_REGION }}
            fi
          fi

      - name: Get stack outputs
        id: stack-outputs
        run: |
          STACK_NAME="complens-${{ needs.setup.outputs.environment }}"

          API_URL=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayURL`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})

          FRONTEND_BUCKET=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendBucketName`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})

          LAMBDA_BUCKET=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --query 'Stacks[0].Outputs[?OutputKey==`LambdaCodeBucketName`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})

          CLOUDFRONT_URL=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontURL`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})

          # Extract CloudFront ID from URL
          CLOUDFRONT_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?contains(Aliases.Items, '${CLOUDFRONT_URL}')].Id | [0]" \
            --output text 2>/dev/null || echo "")

          echo "api-url=${API_URL}" >> $GITHUB_OUTPUT
          echo "frontend-bucket=${FRONTEND_BUCKET}" >> $GITHUB_OUTPUT
          echo "lambda-bucket=${LAMBDA_BUCKET}" >> $GITHUB_OUTPUT
          echo "cloudfront-id=${CLOUDFRONT_ID}" >> $GITHUB_OUTPUT

      - name: Update Secrets Manager with OAuth credentials
        env:
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
        run: |
          STACK_NAME="complens-${{ needs.setup.outputs.environment }}"

          # Get Secrets ARN from stack outputs
          SECRETS_ARN=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --query 'Stacks[0].Outputs[?OutputKey==`SecretsArn`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})

          # Get CloudFront URL for redirect URI
          CLOUDFRONT_URL=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontURL`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})

          # Get API Gateway URL for frontend
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayURL`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})

          # Get current secret value
          CURRENT_SECRET=$(aws secretsmanager get-secret-value \
            --secret-id "${SECRETS_ARN}" \
            --query SecretString \
            --output text \
            --region ${{ env.AWS_REGION }})

          # Merge with Google OAuth credentials (only if they exist)
          if [ -n "$GOOGLE_CLIENT_ID" ] && [ -n "$GOOGLE_CLIENT_SECRET" ]; then
            echo "Updating secret with Google OAuth credentials..."
            NEW_SECRET=$(echo "$CURRENT_SECRET" | jq --arg cid "$GOOGLE_CLIENT_ID" \
              --arg csec "$GOOGLE_CLIENT_SECRET" \
              --arg ruri "${CLOUDFRONT_URL}/api/oauth/google/callback" \
              --arg furl "${CLOUDFRONT_URL}" \
              '. + {
                googleClientId: $cid,
                googleClientSecret: $csec,
                googleRedirectUri: $ruri,
                frontendUrl: $furl
              }')

            # Update the secret
            aws secretsmanager update-secret \
              --secret-id "${SECRETS_ARN}" \
              --secret-string "$NEW_SECRET" \
              --region ${{ env.AWS_REGION }}

            echo "âœ… Google OAuth credentials added to Secrets Manager"
          else
            echo "âš ï¸  Google OAuth credentials not found in GitHub Secrets - skipping"
            echo "    Add GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET to GitHub Secrets"
          fi

  # Deploy Lambda backend
  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: [setup, deploy-infrastructure]
    if: |
      always() &&
      (needs.setup.outputs.deploy-backend == 'true' || github.event_name == 'workflow_dispatch') &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped')
    environment:
      name: ${{ needs.setup.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Lambda bucket from stack
        id: get-bucket
        run: |
          STACK_NAME="complens-${{ needs.setup.outputs.environment }}"
          LAMBDA_BUCKET=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --query 'Stacks[0].Outputs[?OutputKey==`LambdaCodeBucketName`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})
          echo "lambda-bucket=${LAMBDA_BUCKET}" >> $GITHUB_OUTPUT

      - name: Install dependencies
        run: |
          cd backend/lambda/api
          npm install --production

      - name: Build Lambda package
        run: |
          cd backend/lambda/api
          zip -r ../api-${{ github.sha }}.zip . -x '*.git*' 'node_modules/.cache/*' 'tests/*' '*.md'

      - name: Upload to S3
        run: |
          aws s3 cp backend/lambda/api-${{ github.sha }}.zip \
            s3://${{ steps.get-bucket.outputs.lambda-bucket }}/api/latest.zip \
            --region ${{ env.AWS_REGION }}

          # Also upload with commit hash for versioning
          aws s3 cp backend/lambda/api-${{ github.sha }}.zip \
            s3://${{ steps.get-bucket.outputs.lambda-bucket }}/api/${{ github.sha }}.zip \
            --region ${{ env.AWS_REGION }}

      - name: Update Lambda function (if exists)
        run: |
          FUNCTION_NAME="${{ needs.setup.outputs.environment }}-complens-api"

          # Check if function exists
          if aws lambda get-function --function-name ${FUNCTION_NAME} --region ${{ env.AWS_REGION }} 2>&1 | grep -q "ResourceNotFoundException"; then
            echo "Lambda function not yet created by CloudFormation"
            echo "Uncomment ApiLambdaFunction resource in main.yaml and redeploy infrastructure"
          else
            echo "Updating Lambda function code..."
            aws lambda update-function-code \
              --function-name ${FUNCTION_NAME} \
              --s3-bucket ${{ steps.get-bucket.outputs.lambda-bucket }} \
              --s3-key api/latest.zip \
              --region ${{ env.AWS_REGION }}

            # Wait for update to complete
            aws lambda wait function-updated \
              --function-name ${FUNCTION_NAME} \
              --region ${{ env.AWS_REGION }}
          fi

  # Deploy frontend
  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: [setup, deploy-infrastructure, deploy-backend]
    if: |
      always() &&
      (needs.setup.outputs.deploy-frontend == 'true' || github.event_name == 'workflow_dispatch') &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped')
    environment:
      name: ${{ needs.setup.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get stack outputs
        id: get-outputs
        run: |
          STACK_NAME="complens-${{ needs.setup.outputs.environment }}"

          API_URL=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayURL`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})

          FRONTEND_BUCKET=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendBucketName`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})

          CLOUDFRONT_URL=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontURL`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})

          echo "api-url=${API_URL}" >> $GITHUB_OUTPUT
          echo "frontend-bucket=${FRONTEND_BUCKET}" >> $GITHUB_OUTPUT
          echo "cloudfront-url=${CLOUDFRONT_URL}" >> $GITHUB_OUTPUT

          # Verify bucket exists before proceeding
          if [ -z "$FRONTEND_BUCKET" ] || [ "$FRONTEND_BUCKET" = "None" ]; then
            echo "ERROR: Frontend bucket output not found in stack"
            exit 1
          fi

          echo "Verifying frontend bucket exists: ${FRONTEND_BUCKET}"
          if ! aws s3 ls "s3://${FRONTEND_BUCKET}" --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "ERROR: Frontend bucket ${FRONTEND_BUCKET} does not exist!"
            echo "Stack outputs show the bucket but it's not accessible."
            echo "Check CloudFormation stack status:"
            aws cloudformation describe-stacks --stack-name ${STACK_NAME} --query 'Stacks[0].StackStatus'
            exit 1
          fi

          echo "âœ… Frontend bucket verified: ${FRONTEND_BUCKET}"

      - name: Install dependencies
        run: |
          cd frontend
          npm install

      - name: Build frontend
        env:
          REACT_APP_API_URL: ${{ steps.get-outputs.outputs.api-url }}
        run: |
          cd frontend
          npm run build

      - name: Deploy to S3
        run: |
          aws s3 sync frontend/build/ s3://${{ steps.get-outputs.outputs.frontend-bucket }}/ \
            --delete \
            --region ${{ env.AWS_REGION }} \
            --cache-control "public,max-age=31536000,immutable" \
            --exclude "index.html" \
            --exclude "*.map"

          # Upload index.html separately with no cache
          aws s3 cp frontend/build/index.html s3://${{ steps.get-outputs.outputs.frontend-bucket }}/index.html \
            --region ${{ env.AWS_REGION }} \
            --cache-control "public,max-age=0,must-revalidate" \
            --content-type "text/html"

      - name: Invalidate CloudFront cache
        run: |
          # Get CloudFront distribution ID
          DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?DomainName=='${{ steps.get-outputs.outputs.cloudfront-url }}'.substring(8)].Id | [0]" \
            --output text \
            --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")

          if [ -n "$DISTRIBUTION_ID" ] && [ "$DISTRIBUTION_ID" != "None" ]; then
            echo "Invalidating CloudFront distribution: $DISTRIBUTION_ID"
            aws cloudfront create-invalidation \
              --distribution-id ${DISTRIBUTION_ID} \
              --paths "/*" \
              --region ${{ env.AWS_REGION }}
          else
            echo "CloudFront distribution not found, skipping invalidation"
          fi

      - name: Deployment summary
        run: |
          echo "## Deployment Complete! ðŸš€" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend URL:** ${{ steps.get-outputs.outputs.cloudfront-url }}" >> $GITHUB_STEP_SUMMARY
          echo "**API URL:** ${{ steps.get-outputs.outputs.api-url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Test your deployment:" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "# Health check" >> $GITHUB_STEP_SUMMARY
          echo "curl ${{ steps.get-outputs.outputs.api-url }}/health" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Visit frontend" >> $GITHUB_STEP_SUMMARY
          echo "open ${{ steps.get-outputs.outputs.cloudfront-url }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
